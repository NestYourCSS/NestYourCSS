function unnestCSS(cssProvided, prefix = '') {
	// Initialize the parsed CSS array
	let parsedCSS = [];

	// Loop through each rule in the provided CSS
	for (let i = 0; i < cssProvided.length; i++) {
		// If the current rule is an array, it's a nested rule
		if (Array.isArray(cssProvided[i])) {
			// Extract the relative selector and declarations from the current rule
			let [relativeSelector, declarations] = cssProvided[i];

			// If the relative selector starts with '@', append a semicolon to it
			if (relativeSelector.startsWith('@')) relativeSelector += ';';

			// If the declarations are an array, there are nested rules within the current rule
			if (Array.isArray(declarations)) {
				let absoluteSelector = prefix + ((relativeSelector.startsWith('&:') || !prefix) ? '' : ' ') + relativeSelector;
				
				// If not all declarations are arrays, add them to the parsed CSS
				if (!declarations.every(Array.isArray)) {
					parsedCSS.push([absoluteSelector, declarations.filter((d) => typeof d === 'string').join(';')]);
				}

				// Recursively call the function to unnest the nested rules, and concatenate the result to the parsed CSS
				parsedCSS = parsedCSS.concat(unnestCSS(declarations.filter(Array.isArray).map((declaration) => declaration.slice(0, relativeSelector.length)), absoluteSelector));
			} else {
				// If the declarations are not an array, add them to the parsed CSS

				// Split selector groups:
				let splitSelectors = [];
				let currentSelector = '';
				let parenthesisDepth = 0;
				let bracketDepth = 0;
				let isInSingleQuotes = false;
				let isInDoubleQuotes = false;

				for (let i = 0; i < relativeSelector.length; i++) {
					const char = relativeSelector[i];

					currentSelector += char;
					
					switch (char) {
						case '(':
							parenthesisDepth++;
							break;
						case ')':
							parenthesisDepth--;
							break;
						case '[':
							bracketDepth++;
							break;
						case ']':
							bracketDepth--;
							break;
						case '"':
							isInDoubleQuotes = !isInDoubleQuotes;
							break;
						case "'":
							isInSingleQuotes = !isInSingleQuotes;
							break;
					}

					if ((!currentSelector.startsWith('@') && char == ',' && parenthesisDepth == 0 && bracketDepth == 0 && !isInSingleQuotes && !isInDoubleQuotes) || (i + 1) == relativeSelector.length) {
						splitSelectors.push(currentSelector.split(',').join('').trim());
						currentSelector = '';
					}

					// This part of the code makes it clear an @at-rule is another nested selector.
					if (char == ';' && parenthesisDepth == 0 && bracketDepth == 0 && !isInSingleQuotes && !isInDoubleQuotes) {
						atRule = currentSelector + ' ';
						console.log(currentSelector);
						currentSelector = '';
					}
				}

				let splitSelectorsWithPrefix = splitSelectors.map((newSelector) => prefix + ((newSelector.startsWith('&:') || !prefix) ? '' : ' ') + newSelector);
				parsedCSS.push(...splitSelectorsWithPrefix.map((newSelector) => [newSelector, declarations]));
			}
		} else {
			// If the current rule is not an array, add it to the parsed CSS
			parsedCSS.push([cssProvided[i]])
		}
	}

	// Return the parsed CSS
	return parsedCSS;
}